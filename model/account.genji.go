// Code generated by genji.
// DO NOT EDIT!

package model

import (
	"errors"

	"github.com/asdine/genji/field"
	"github.com/asdine/genji/index"
	"github.com/asdine/genji/query"
	"github.com/asdine/genji/record"
)

// GetField implements the field method of the record.Record interface.
func (a *Account) GetField(name string) (field.Field, error) {
	switch name {
	case "ID":
		return field.NewString("ID", a.ID), nil
	case "Name":
		return field.NewString("Name", a.Name), nil
	case "Provider":
		return field.NewString("Provider", a.Provider), nil
	case "Email":
		return field.NewString("Email", a.Email), nil
	case "ImapHost":
		return field.NewString("ImapHost", a.ImapHost), nil
	case "ImapPort":
		return field.NewUint16("ImapPort", a.ImapPort), nil
	case "ImapUsername":
		return field.NewString("ImapUsername", a.ImapUsername), nil
	case "ImapPassword":
		return field.NewString("ImapPassword", a.ImapPassword), nil
	case "SmtpHost":
		return field.NewString("SmtpHost", a.SmtpHost), nil
	case "SmtpPort":
		return field.NewUint16("SmtpPort", a.SmtpPort), nil
	case "SmtpUsername":
		return field.NewString("SmtpUsername", a.SmtpUsername), nil
	case "SmtpPassword":
		return field.NewString("SmtpPassword", a.SmtpPassword), nil
	case "SslRequired":
		return field.NewBool("SslRequired", a.SslRequired), nil
	}

	return field.Field{}, errors.New("unknown field")
}

// Iterate through all the fields one by one and pass each of them to the given function.
// It the given function returns an error, the iteration is interrupted.
func (a *Account) Iterate(fn func(field.Field) error) error {
	var err error

	err = fn(field.NewString("ID", a.ID))
	if err != nil {
		return err
	}

	err = fn(field.NewString("Name", a.Name))
	if err != nil {
		return err
	}

	err = fn(field.NewString("Provider", a.Provider))
	if err != nil {
		return err
	}

	err = fn(field.NewString("Email", a.Email))
	if err != nil {
		return err
	}

	err = fn(field.NewString("ImapHost", a.ImapHost))
	if err != nil {
		return err
	}

	err = fn(field.NewUint16("ImapPort", a.ImapPort))
	if err != nil {
		return err
	}

	err = fn(field.NewString("ImapUsername", a.ImapUsername))
	if err != nil {
		return err
	}

	err = fn(field.NewString("ImapPassword", a.ImapPassword))
	if err != nil {
		return err
	}

	err = fn(field.NewString("SmtpHost", a.SmtpHost))
	if err != nil {
		return err
	}

	err = fn(field.NewUint16("SmtpPort", a.SmtpPort))
	if err != nil {
		return err
	}

	err = fn(field.NewString("SmtpUsername", a.SmtpUsername))
	if err != nil {
		return err
	}

	err = fn(field.NewString("SmtpPassword", a.SmtpPassword))
	if err != nil {
		return err
	}

	err = fn(field.NewBool("SslRequired", a.SslRequired))
	if err != nil {
		return err
	}

	return nil
}

// ScanRecord extracts fields from record and assigns them to the struct fields.
// It implements the record.Scanner interface.
func (a *Account) ScanRecord(rec record.Record) error {
	return rec.Iterate(func(f field.Field) error {
		var err error

		switch f.Name {
		case "ID":
			a.ID, err = field.DecodeString(f.Data)
		case "Name":
			a.Name, err = field.DecodeString(f.Data)
		case "Provider":
			a.Provider, err = field.DecodeString(f.Data)
		case "Email":
			a.Email, err = field.DecodeString(f.Data)
		case "ImapHost":
			a.ImapHost, err = field.DecodeString(f.Data)
		case "ImapPort":
			a.ImapPort, err = field.DecodeUint16(f.Data)
		case "ImapUsername":
			a.ImapUsername, err = field.DecodeString(f.Data)
		case "ImapPassword":
			a.ImapPassword, err = field.DecodeString(f.Data)
		case "SmtpHost":
			a.SmtpHost, err = field.DecodeString(f.Data)
		case "SmtpPort":
			a.SmtpPort, err = field.DecodeUint16(f.Data)
		case "SmtpUsername":
			a.SmtpUsername, err = field.DecodeString(f.Data)
		case "SmtpPassword":
			a.SmtpPassword, err = field.DecodeString(f.Data)
		case "SslRequired":
			a.SslRequired, err = field.DecodeBool(f.Data)
		}
		return err
	})
}

// PrimaryKey returns the primary key. It implements the table.PrimaryKeyer interface.
func (a *Account) PrimaryKey() ([]byte, error) {
	return field.EncodeString(a.ID), nil
}

// Indexes creates a map containing the configuration for each index of the table.
func (a *Account) Indexes() map[string]index.Options {
	return map[string]index.Options{
		"Email": index.Options{Unique: true},
	}
}

// AccountFields describes the fields of the Account record.
// It can be used to select fields during queries.
type AccountFields struct {
	ID           query.StringFieldSelector
	Name         query.StringFieldSelector
	Provider     query.StringFieldSelector
	Email        query.StringFieldSelector
	ImapHost     query.StringFieldSelector
	ImapPort     query.Uint16FieldSelector
	ImapUsername query.StringFieldSelector
	ImapPassword query.StringFieldSelector
	SmtpHost     query.StringFieldSelector
	SmtpPort     query.Uint16FieldSelector
	SmtpUsername query.StringFieldSelector
	SmtpPassword query.StringFieldSelector
	SslRequired  query.BoolFieldSelector
}

// NewAccountFields creates a AccountFields.
func NewAccountFields() *AccountFields {
	return &AccountFields{
		ID:           query.StringField("ID"),
		Name:         query.StringField("Name"),
		Provider:     query.StringField("Provider"),
		Email:        query.StringField("Email"),
		ImapHost:     query.StringField("ImapHost"),
		ImapPort:     query.Uint16Field("ImapPort"),
		ImapUsername: query.StringField("ImapUsername"),
		ImapPassword: query.StringField("ImapPassword"),
		SmtpHost:     query.StringField("SmtpHost"),
		SmtpPort:     query.Uint16Field("SmtpPort"),
		SmtpUsername: query.StringField("SmtpUsername"),
		SmtpPassword: query.StringField("SmtpPassword"),
		SslRequired:  query.BoolField("SslRequired"),
	}
}
